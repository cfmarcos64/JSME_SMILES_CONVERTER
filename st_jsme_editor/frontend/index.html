<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSME Streamlit Component</title>
    <!-- Carga de Tailwind CSS para estilos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Aplicar la fuente Inter de Tailwind */
        body { font-family: 'Inter', sans-serif; }
    </style>
    
    <!-- Carga del Componente de Streamlit -->
    <script src="https://unpkg.com/@streamlit/component-lib/dist/streamlit-component-lib.js"></script>
    
    <!-- Carga del Editor Molecular JSME -->
    <script src="https://jsme-editor.github.io/dist/jsme/jsme.nocache.js"></script>
</head>

<body class="bg-gray-50 p-2 antialiased">

    <div id="root" class="w-full">
        <div id="jsme_container" class="border-2 border-indigo-200 rounded-lg overflow-hidden shadow-lg bg-white">
            <!-- El editor JSME se renderizará aquí -->
        </div>

        <div class="mt-4 p-3 bg-indigo-100 rounded-lg shadow-inner">
            <label class="block text-xs font-semibold uppercase text-indigo-700">
                SMILES JSME (No Canónico):
            </label>
            <p id="smiles_output" class="mt-1 p-2 bg-white border border-indigo-300 rounded text-sm font-mono break-all text-gray-800">
                Esperando SMILES...
            </p>
        </div>
    </div>

    <script>
        // Variables globales necesarias
        let jsmeApplet = null;
        let componentReady = false;

        // --- Funciones de Callback de JSME ---

        // Función llamada por el editor JSME cuando la estructura es modificada por el usuario.
        function jsmeModifiedCallback(jsme) {
            try {
                // Obtiene el SMILES no canónico actual
                const currentSmiles = jsme.smiles(); 
                
                // Actualiza el campo de salida visible
                const output = document.getElementById("smiles_output");
                output.textContent = currentSmiles || "Lienzo limpio"; 

                // Envía el valor de vuelta a Python
                if (typeof Streamlit !== 'undefined') {
                    Streamlit.setComponentValue(currentSmiles);
                }

            } catch (e) {
                console.error("Error en jsmeModifiedCallback al interactuar con Streamlit:", e);
            }
        }

        // Función llamada por el editor JSME cuando termina de cargarse.
        window.jsmeOnLoad = function () {
            try {
                // Inicialización del applet de JSME
                jsmeApplet = new JSApplet.JSME("jsme_container", "100%", "100%", { 
                    "options": "query",
                    "depict": false
                });
                
                // CORRECCIÓN CRÍTICA: Usar la sintaxis de setCallBack con el evento correcto
                jsmeApplet.setCallBack("AfterStructureModified", jsmeModifiedCallback);
                
                console.log("[JSME] Applet cargado y callback configurado (usando setCallBack).");

                // Si Streamlit ya está listo, forzamos una carga con el valor inicial de Python
                if (componentReady) {
                    const initialSmiles = Streamlit.args.smiles || "";
                    loadSmilesAndSendBack(initialSmiles);
                }
                
                // Forzar repintado inicial para el problema de visibilidad
                jsmeApplet.repaint(); 

            } catch (e) {
                console.error("Error al inicializar el Applet de JSME:", e);
                const output = document.getElementById("smiles_output");
                output.textContent = "Error de carga de JSME: " + e.message;
            }
        };


        // --- Funciones de Comunicación con Streamlit ---

        function loadSmilesAndSendBack(canonicalSmiles) {
            
            const output = document.getElementById("smiles_output");
            
            // 1. Actualiza la altura del iframe de Streamlit
            if (typeof Streamlit !== 'undefined') {
                Streamlit.setFrameHeight(document.documentElement.offsetHeight);
            }

            if (jsmeApplet) {
                const smilesToLoad = canonicalSmiles || "";
                
                // Limpia la salida si el SMILES está vacío
                if (smilesToLoad === "") {
                    output.textContent = "Lienzo limpio";
                    jsmeApplet.clear();
                    jsmeApplet.repaint(); 
                    if (typeof Streamlit !== 'undefined') {
                        Streamlit.setComponentValue("");
                    }
                    console.log("[LOAD] Lienzo limpiado y SMILES vacío enviado.");
                    return;
                }

                try {
                    // Carga el SMILES canónico en el editor
                    jsmeApplet.readGenericMolecularInput(smilesToLoad);
                    console.log(`[LOAD] SMILES canónico cargado: ${smilesToLoad}`);
                    
                    // 2. Obtiene el SMILES no canónico generado por JSME
                    const jsmeSmiles = jsmeApplet.smiles(false); 
                    
                    // 3. Forzar el redibujado
                    jsmeApplet.repaint(); 

                    // 4. Actualiza la salida visible y el valor de retorno
                    output.textContent = jsmeSmiles; 
                    if (typeof Streamlit !== 'undefined') {
                         Streamlit.setComponentValue(jsmeSmiles);
                    }
                    console.log(`[RETURN] SMILES JSME generado: ${jsmeSmiles}`);

                } catch (e) {
                    output.textContent = `Error al procesar SMILES: ${e.message}`;
                    console.error("Error al procesar SMILES en JSME:", e);
                }
            } else {
                console.warn("[LOAD] JSME Applet no está listo todavía.");
            }
        }

        // Función de renderizado principal (llamada por Streamlit en cada actualización)
        function onRender(event) {
            const data = event.detail;
            const canonicalSmiles = data.args["smiles"];
            const height = data.args["height"] || 400; // Altura del componente

            // 1. Asegura que el editor y su contenedor tengan el tamaño correcto
            const container = document.getElementById("jsme_container");
            container.style.height = `${height}px`;
            
            // 2. Carga la molécula si el editor está listo
            loadSmilesAndSendBack(canonicalSmiles);
        }

        // --- Inicialización del Ciclo de Vida ---
        
        function initializeStreamlitLoop() {
            if (typeof Streamlit !== 'undefined') {
                console.log("[Streamlit] Librería cargada. Inicializando componente.");
                
                // CORRECCIÓN CRÍTICA: Llamar a setComponentReady INMEDIATAMENTE para resolver el timeout.
                Streamlit.setComponentReady();
                componentReady = true;

                // Configuración de eventos después de setComponentReady
                Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender);

                // Llamada inicial a onRender con los argumentos iniciales
                if (Streamlit.args) {
                    onRender({ detail: { args: Streamlit.args } });
                }

            } else {
                // Reintentar en 50ms
                setTimeout(initializeStreamlitLoop, 50); 
            }
        }

        // Iniciar la verificación inmediatamente.
        initializeStreamlitLoop();

    </script>
</body>
</html>

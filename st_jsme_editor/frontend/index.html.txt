<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSME Editor Streamlit Component</title>
    <!-- Carga de Tailwind CSS para el estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carga de la librería del componente Streamlit -->
    <script src="https://unpkg.com/@streamlit/component-lib/dist/streamlit-component-lib.js"></script>
    <!-- Carga de la librería JSME -->
    <script src="https://jsme-editor.github.io/dist/jsme/jsme.nocache.js"></script>
    <style>
        /* Estilos adicionales para asegurar el diseño responsivo y la fuente */
        body { font-family: 'Inter', sans-serif; background-color: #f0f2f6; }
        #jsme_container { border: 1px solid #ccc; border-radius: 6px; overflow: hidden; }
    </style>
    <script>
        // Variables globales para el editor JSME
        let jsmeApplet = null;
        let canonicalSmiles = "";
        let componentHeight = 400;

        /**
         * 1. Callback de JSME: Se llama automáticamente cuando el script JSME se ha cargado
         * y está listo para inicializar el editor.
         */
        window.jsmeOnLoad = function() {
            const containerId = "jsme_container";
            
            try {
                // Inicializar el editor JSME
                jsmeApplet = new JSApplet.JSME(
                    containerId,
                    "100%", 
                    `${componentHeight}px`,
                    "" // Opciones adicionales si fueran necesarias
                );
                console.log("jsmeOnLoad: Editor JSME inicializado con éxito.");

                // 2. Configurar el callback para que cualquier cambio manual en el editor 
                // envíe el SMILES no canónico a Streamlit.
                jsmeApplet.setCallBack("AfterStructureModified", jsmeModifiedCallback);
                
                // Si ya teníamos un SMILES de Streamlit (establecido por onRender), cargarlo ahora.
                if (canonicalSmiles) {
                    console.log("jsmeOnLoad: JSME listo y canonicalSmiles ya disponible, cargando estructura.");
                    loadSmilesAndSendBack(canonicalSmiles);
                } else {
                    console.log("jsmeOnLoad: JSME listo, esperando canonicalSmiles de Streamlit.");
                    // Forzar limpieza inicial si el SMILES era vacío desde el principio
                    loadSmilesAndSendBack("");
                }

            } catch (error) {
                // Este catch ya estaba, pero ahora sabemos que el error puede venir de loadSmilesAndSendBack
                console.error("Error al inicializar el Applet de JSME:", error);
            }
        };

        /**
         * Función principal para cargar el SMILES y obtener el SMILES JSME (no canónico).
         * @param {string} smiles La cadena SMILES a cargar.
         */
        function loadSmilesAndSendBack(smiles) {
            if (jsmeApplet) {
                // 1. Manejar el caso de SMILES vacío o nulo: limpiar el lienzo
                if (!smiles || smiles.trim() === "") {
                    jsmeApplet.clear();
                    const emptySmiles = "";
                    
                    // Solo intentar enviar el valor si Streamlit está definido
                    if (typeof Streamlit !== 'undefined') { 
                        Streamlit.setComponentValue(emptySmiles);
                    } else {
                        console.warn("loadSmilesAndSendBack: Streamlit no definido. No se pudo enviar el valor vacío.");
                    }

                    document.getElementById('smiles_output').textContent = "Lienzo limpio.";
                    console.log("loadSmilesAndSendBack: SMILES vacío o nulo, lienzo limpiado.");
                    return;
                }

                // Caso de SMILES válido:
                console.log(`loadSmilesAndSendBack: Intentando cargar SMILES: ${smiles}`);
                
                // Cargar el SMILES canónico en el editor. JSME se encarga del renderizado.
                jsmeApplet.readGenericMolecularInput(smiles);

                // Extraer el SMILES no canónico generado por el motor de dibujo de JSME
                const jsmeSmiles = jsmeApplet.smiles();
                
                // Enviar el resultado de vuelta a Streamlit y actualizar el display
                // Solo intentar enviar el valor si Streamlit está definido
                if (typeof Streamlit !== 'undefined') {
                    Streamlit.setComponentValue(jsmeSmiles);
                } else {
                    console.warn("loadSmilesAndSendBack: Streamlit no definido. No se pudo enviar el SMILES generado.");
                }

                document.getElementById('smiles_output').textContent = jsmeSmiles;
                console.log(`loadSmilesAndSendBack: SMILES no canónico generado y enviado: ${jsmeSmiles}`);

            } else {
                console.error("loadSmilesAndSendBack: JSME Applet no está disponible.");
            }
        }
        
        /**
         * Callback que se llama cuando el usuario edita manualmente la molécula.
         */
        function jsmeModifiedCallback() {
            if (jsmeApplet) {
                const jsmeSmiles = jsmeApplet.smiles();
                
                // Solo intentar enviar el valor si Streamlit está definido
                if (typeof Streamlit !== 'undefined') {
                    Streamlit.setComponentValue(jsmeSmiles);
                } else {
                    console.warn("jsmeModifiedCallback: Streamlit no definido. No se pudo enviar el SMILES modificado.");
                }

                document.getElementById('smiles_output').textContent = jsmeSmiles;
                console.log(`jsmeModifiedCallback: Nueva estructura dibujada, SMILES enviado: ${jsmeSmiles}`);
            }
        }

        /**
         * 3. Callback de Streamlit: Se llama cada vez que Streamlit (Python)
         * envía nuevos argumentos.
         */
        function onRender(event) {
            const args = event.detail.args;
            const newSmiles = args["smiles"];
            const newHeight = args["height"] || 400;

            console.log(`onRender: Recibido SMILES de Streamlit: ${newSmiles}`);

            if (newSmiles !== canonicalSmiles) {
                canonicalSmiles = newSmiles;
                
                // 1. Actualizar el texto de salida inmediatamente para mostrar el valor de entrada.
                document.getElementById('smiles_output').textContent = canonicalSmiles || "Lienzo limpio.";

                // 2. Si JSME está listo, cargamos la estructura. Si no, esperamos a jsmeOnLoad.
                if (jsmeApplet) {
                    loadSmilesAndSendBack(canonicalSmiles);
                } else {
                    console.log("onRender: JSME aún no está inicializado. Esperando jsmeOnLoad para cargar la estructura.");
                }
            }

            // Actualizar la altura del contenedor si ha cambiado
            if (newHeight !== componentHeight) {
                componentHeight = newHeight;
                const container = document.getElementById("jsme_container");
                if(container) {
                    container.style.height = `${componentHeight}px`;
                    // Esta llamada puede no ser suficiente para redimensionar el iframe en Streamlit
                }
            }

            // Establecer la altura del marco para Streamlit (el contenedor total)
            const totalHeight = componentHeight + 100; // Altura del editor + 100px para el título/salida
            Streamlit.setFrameHeight(totalHeight);
        }

        /**
         * 4. Bucle de sondeo para inicializar Streamlit solo cuando esté definido.
         */
        function initializeStreamlitLoop() {
            if (typeof Streamlit !== 'undefined') {
                // Streamlit está listo.
                Streamlit.events.addEventListener(Streamlit.events.RENDER_EVENT, onRender);
                Streamlit.setComponentReady();
                console.log("Streamlit Component Ready y event listener agregado.");
            } else {
                // Streamlit aún no está definido, reintentar después de un breve retraso.
                console.log("Streamlit component library still loading...");
                // Reintentar en 50 milisegundos
                window.setTimeout(initializeStreamlitLoop, 50);
            }
        }

        // 5. Iniciar el bucle de verificación
        window.setTimeout(initializeStreamlitLoop, 0);

    </script>
</head>
<body class="p-4">
    <div class="space-y-4">
        <h2 class="text-xl font-semibold text-gray-800">Editor Molecular JSME</h2>
        <div 
            id="jsme_container" 
            style="width: 100%; height: 400px;"
            class="shadow-lg bg-white"
        >
            <!-- El editor JSME se renderizará aquí -->
        </div>
        <div class="bg-white p-4 rounded-lg shadow-md border border-gray-200">
            <p class="font-medium text-gray-700 mb-1">SMILES JSME (No Canónico):</p>
            <code 
                id="smiles_output" 
                class="block p-2 bg-gray-50 text-blue-600 rounded-md break-all"
            >
                Esperando SMILES...
            </code>
            <p class="text-xs text-gray-500 mt-2">
                *Este valor se envía automáticamente de vuelta a la aplicación Streamlit.
            </p>
        </div>
    </div>
</body>
</html>